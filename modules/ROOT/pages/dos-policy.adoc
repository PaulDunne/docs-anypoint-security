= Denial Of Service Policy

The Denial of service (DoS) policy prevents attackers from flooding your network to prevent legitimate network traffic to your APIs. +
Malicious clients, for example, could send huge malicious payloads designed to consume resources and bandwidth.

Application Layer threats are  gaining more traction and they are harder to detect and mitigate. This is a distinctive and critical functionality to secure your application network against DDoS (Distributed Denial of Service) attacks from HTTP clients.

The DoS policy allows you to configure a time window, and set up conditions for each type of error encountered. If the policy encounters more errors than your tolerated amount coming from the same IP address, the policy can either drop the connection silently (doesn't attempt the TLS connection), or drop the connection immediately returning a 503 (a TLS connection has to be made in this case).

This source is IP based. If an attacker can spoof his source IP address, these measurements cannot prevent the attack.

== Escalating Policy Violations as Errors

Other Anypoint Security policy violations escalate as errors that the DoS policy catches. +
If you have a DoS policy configured, HTTP protocol errors (malicious protocol violation attempts), and ACL and CAP policy violations escalate directly to DoS. Additionally, Some API Gateway provided policies escalate directly to DoS as well. See the table below for a specific mapping of violations and error escalations:

[%header%autowidth.spread,cols="a,a"]
|===
2+^.^| *Anypoint Security Policy*
| *Violation* | *Escalates as*
| ACL Policy | Authentication Error
| CAP Policy | Protocol Error
2+^.^| *API Gateway Provided Policy*
| *Violation* | *Escalates as*
| Client ID Enforcement | Authentication Error
| Mule OAuth 2.0 Access Token | Authentication Error
| OpenAM OAuth 2.0 Token Enforcement Policy | Authentication Error
| OpenID Connect OAuth 2.0 Token Enforcement | Authentication Error
| PingFederate OAuth 2.0 Token Enforcement | Authentication Error
| Basic Authentication: Simple | Authentication Error
| Basic Authentication: LDAP | Authentication Error
| IP Blacklist | Content Error
| IP Whitelist | Content Error
| JSON Threat Protection | Content Error
| XML Threat Protection | Content Error
| Rate Limiting and Throttling - SLA-Based Policies concepts | QoS Error
| Rate Limiting and Throttling | QoS Error
| Throttling and Rate Limiting | QoS Error
|===


== Configuring a DoS Policy

. Navigate to *Anypoint Security*, click the *Create Policy* icon, and select *Denial Of Service*. +
The process of applying a DOS Policy has six different screens. +
For every screen in the process, you need to save the changes. If you leave one screen without saving, you loose your changes on that screen.
. Click *General* on the left navigation bar:
.. Add a name for your policy in the *Name* field.
.. Set up a time interval, in seconds, in the *Window1 Time Period*. +
This time interval is the accepted time that your policy will block other requests if it encounters the amount of errors that you configure for each type of error.
.. Use the *Max Sources To Monitor* field to set up a maximum amount of IP address to track. +
The DoS Policy can track up to 50000 IP addresses.
.. Use the *Reject Message Action* drop-down menu to select the type of response the policy returns when dropping a client connection. You have two options:
* *Drop Silently*: The policy drops the connection silently and avoids making the TLS handshake altogether. The policy avoids making the connection for the tcp packets with source ip address in AWS ELB Proxy Protocol headers, or for source ip address taken from the tcp packet. This is the most efficient way to terminate the client's connection, as the policy avoids reading the attacker's request.
* *Send HTTP 503*: The policy terminates the connection and returns a 503 (Service Unavailable) response to the client. This requires for a TLS connection to be made., therefore being quite resource expensive.
+
[TIP]
--
If your applications are behind a AWS or load balancer, you must use this reject action, as the policy needs to read the attacker's request to identify the source IP headers in the HTTP message such as ‘x-forwarded-for’ or ‘forwarded’, before applying a DoS action.
--
. Now you can configure your policy to take action for:
* *Protocol Errors*
* *Routing Errors*
* *Authentication Errors*
* *QoS Errors*
* *Content Errors*

=== Protocol Errors

This error detection prevents attack methods based on protocol violations. +
For example, a CAP policy violation escalates directly as a protocol error, since we are enforcing a maximum size for the client's message.

=== Configuring Protocol Errors Protection

. Click *Protocol Errors* on the left navigation bar:
.. Check the *Protocol Errors* checkmark if you want to enable protocol errors protection. +
You can configure up to 3 windows, and five different actions for each one:
* *None*: The policy performs no action when encountering the configured amount of protocol errors.
* *Shape-Interval*: The policy restricts the client's message rate until the end of your configured time window.
* *Block-Interval*: The policy rejects the client's message requests until the end of your configured time window.
* *Block-Forever*: The policy rejects all message requests from the client.
.. Click *Save*.

=== Routing Errors

This error prevention catches malicious routing loops. +
Violations to IP blacklist/whitelist or RAML validation policies in API Manager escalate as routing errors.


==== Configuring Routing Errors Protection

. Click *Routing Errors* on the left navigation bar:
.. Check the *Routing Errors* checkmark if you want to enable routing errors protection. +
You can configure up to 3 windows, and five different actions for each one:
* *None*: The policy performs no action when encountering the configured amount of routing errors.
* *Shape-Interval*: The policy restricts the client's message rate until the end of your configured time window.
* *Block-Interval*: The policy rejects the client's message requests until the end of your configured time window.
* *Block-Forever*: The policy rejects all message requests from the client.
.. Click *Save*.

=== Authentication Errors

This error detection prevents a client, for example, from trying to infringe a login to your application by force brut. +
For example, you can configure your policy to permit up to 4 authentication errors within a 5 minute timeframe. If the client attempts a fifth login error, you can assume this IP address is trying to force brut its access, and take action against this. +
The same would apply for credit card attacks. An attacker might have a full credit card number, and may be trying to brut force credit card's CVC. You can block these malicious attempts before the attacker gets a significant number of correct values.

Violations to a LDAP, HTTP, OAuth, OpenAM, or Ping Federate authentication policies in API Manager escalate as authentication errors.

==== Configuring Authentication Errors Protection

. Click *Authentication Errors* on the left navigation bar:
.. Check the *Authentication Errors* checkmark if you want to enable authentication errors protection. +
You can configure up to 3 windows, and five different actions for each one:
* *None*: The policy performs no action when encountering the configured amount of authentication errors.
* *Shape-Interval*: The policy restricts the client's message rate until the end of your configured time window.
* *Block-Interval*: The policy rejects the client's message requests until the end of your configured time window.
* *Block-Forever*: The policy rejects all message requests from the client.
.. Click *Save*.

=== QoS Errors

A client may try to force a lot of QoS (quality of service) errors by dropping packets to degrade the TCP service damaging your TCP performance. +
Violations to a rate limiting, or SLA based, or Ping Federate policy at the API Manager level escalates as a QoS error.

==== Configuring QoS Errors Protection

. Click *QoS Errors* on the left navigation bar:
.. Check the *QoS Errors* checkmark if you want to enable QoS errors protection. +
You can configure up to 3 windows, and five different actions for each one:
* *None*: The policy performs no action when encountering the configured amount of QoS errors.
* *Shape-Interval*: The policy restricts the client's message rate until the end of your configured time window.
* *Block-Interval*: The policy rejects the client's message requests until the end of your configured time window.
* *Block-Forever*: The policy rejects all message requests from the client.
.. Click *Save*.

==== Content Errors

This error prevention catches malicious requests that send payloads with unusual inflation of elements. An attackers could be using recursive techniques to consume memory resources. +
Violations to a JSON or XML threat protection policy at the API Manager level escalates as a content error.

==== Configuring Content Errors Protection

. Click *Content Errors* on the left navigation bar:
.. Check the *Content Errors* checkmark if you want to enable content errors protection. +
A client may try to force a lot of QoS (quality of service) errors by dropping packets to degrade the TCP service damaging your TCP performance.
You can configure up to 3 windows, and five different actions for each one:
* *None*: The policy performs no action when encountering the configured amount of content errors.
* *Shape-Interval*: The policy restricts the client's message rate until the end of your configured time window.
* *Block-Interval*: The policy rejects the client's message requests until the end of your configured time window.
* *Block-Forever*: The policy rejects all message requests from the client.
.. Click *Save*.

== See Also

* xref:acl-policy.adoc[ACL Policy]
* xref:cap-policy.adoc[CAP Policy]
